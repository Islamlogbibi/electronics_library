#pragma once
#include <vector>
#include <string>

using namespace std;
#define DC_circuit 0x6C058E04
#define AC_circuit 0xC8684A69
#define AC_circuit_single_phase 0x42EA42DC
#define AC_cicuit_3_phase 0x5671E6E5
#define line_to_line 0xF855055B
#define RMS_Const 0.707
#define R_t 0xE9864CD9
#define I_1 0x4478917C
#define Pi 3.14
#define electron_charge   -1.602*pow(10,-19)
#define prodton_charge  1.602*pow(10,-19)
#define coulomb_constant  8.988*pow(10, 9)
#define line_to_zero 0x0004

/*
Electrical Voltage

Electrical voltage is defined as electric potential difference between two points of an electric field.

Using water pipe analogy, we can visualize the voltage as height difference that makes the water flow down.

V = φ1 - φ2

V is the voltage between point 2 and 1 in volts (V).

φ2 is the electric potential at point #2 in volts (V).

φ1 is the electric potential at point #1 in volts (V).

*/
float E_Voltage_v1(float φ2,float φ1) { //done
    float v = φ2 - φ1;
    return v;
}
/*
In an electrical circuit, the electrical voltage V in volts (V) is equal to the energy consumption E in joules (J)

divided by the electric charge Q in coulombs (C).

V=E/Q

V is the voltage measured in volts (V)

E is the energy measured in joules (J)

Q is the electric charge measured in coulombs (C)

*/
float E_Voltage_v2(float E,float Q) { //done
    float v = E / Q;
    return v; 
}
/*

Voltage in series
The total voltage of several voltage sources or voltage drops in series is their sum.

VT = V1 + V2 + V3 +...

VT - the equivalent voltage source or voltage drop in volts (V).

V1 - voltage source or voltage drop in volts (V).

V2 - voltage source or voltage drop in volts (V).

V3 - voltage source or voltage drop in volts (V).

*/
float Voltage_Series(vector<float> v_series) { //done
    float sum = 0;
    for (const float & i : v_series) {
        sum = sum + i;
    }
    return sum;
  
}

/*
Voltage divider
For electrical circuit with resistors (or other impedance) in series, the voltage drop Vi on resistor Ri
Voltage divider rule for DC circuit
For a DC circuit with constant voltage source VT and resistors in series, the voltage drop Vi in resistor Ri is given by the formula:


Vi=VT x RI/R1+R2+R3....


Vi - voltage drop in resistor Ri in volts [V].

VT - the equivalent voltage source or voltage drop in volts [V].

Ri - resistance of resistor Ri in ohms [Ω].

R1 - resistance of resistor R1 in ohms [Ω].

R2 - resistance of resistor R2 in ohms [Ω].

R3 - resistance of resistor R3 in ohms [Ω].


Voltage divider for AC circuit
For an AC circuit with voltage source VT and loads in series, the voltage drop Vi in load Zi is given by the formula:

Vi=VT x ZI/Z1+Z2+Z3....

Vi - voltage drop in load Zi in volts [V].

VT - the equivalent voltage source or voltage drop in volts [V].

Zi - impedance of load Zi in ohms [Ω].

Z1 - impedance of load Z1 in ohms [Ω].

Z2 - impedance of load Z2 in ohms [Ω].

Z3 - impedance of load Z3 in ohms [Ω].
*/
float Voltage_Divider(float vt, float Ri, vector<float>R) { //done
    float sum_r = 0;

    for (const float & i :R)
    {
        sum_r = sum_r + i;
    }
    
    float vi = (vt) * (Ri / sum_r);

    return vi;

}

/*
DC circuit
Direct current (DC) is generated by a constant voltage source like a battery or DC voltage source.

The voltage drop on a resistor can be calculated from the resistor's resistance and the resistor's current, using Ohm's law:

Voltage calculation with Ohm's law
VR = IR × R

VR - voltage drop on the resistor measured in volts (V)

IR - current flow through the resistor measured in amperes (A)

R - resistance of the resistor measured in ohms (Ω)

AC circuit
Alternating current is generated by a sinusoidal voltage source.

Ohm's law
VZ = IZ × Z

VZ - voltage drop on the load measured in volts (V)

IZ - current flow through the load measured in amperes (A)

Z - impedance of the load measured in ohms (Ω)

*/
float Voltage_ohm(float i ,float r,float Iz,float Z,int circuit) { //done
    if (circuit==DC_circuit)
    {
        float vr = i * r;
        return vr;
    }

    else if(circuit==AC_circuit)
    {
        float vz = Iz * Z;
        return vz;
    }
    else
    {
        return 0;
    }

}

/*
Momentary voltage
v(t) = Vmax × sin(ωt+θ)

v(t) - voltage at time t, measured in volts (V).

Vmax - maximal voltage (=amplitude of sine), measured in volts (V).

ω      - angular frequency measured in radians per second (rad/s).

t        - time, measured in seconds (s).

θ       - phase of sine wave in radians (rad).

*/
float momentry_Voltage(float MaximalVoltage,float w ,float θ,float t) { //done
    float v_t = MaximalVoltage * sin((w * t) + θ);
    return v_t;

}
/*
RMS (effective) voltage
Vrms = Veff  =  Vmax / √2 ≈ 0.707 Vmax

Vrms -  RMS voltage, measured in volts (V).

Vmax - maximal voltage (=amplitude of sine), measured in volts (V).
*/
float RMS_Voltage(float Vmax) { //done
    float v = Vmax * RMS_Const;
    return v;
}
/*
Peak-to-peak voltage
Vp-p = 2Vmax
*/
float VoltageP_P(float Vmax) { //done
    float v = 2 * Vmax;
    return v; 
}
/*
I = ΔQ / Δt

I is the current in amps (A).

ΔQ is the electric charge in coulombs (C), that flows at time duration of Δt.

Δt is the time duration in seconds (s).
*/
float Electric_Current(float q, float t) { //done
    float i = q / t;
    return i;

};
/*
The current IR in anps (A) is equal to the resistor's voltage VR in volts (V) divided by the resistance R in ohms (Ω).
*/
float Electric_current_Ohm(float v ,float R ) { //done
    float i = v / R;
    return i; 
}

/*
Current in parallel circuits
Current that flows through loads in parallel - just like water flow through parallel pipes.

The total current ITotal is the sum of the parallel currents of each load:

ITotal = I1 + I2 + I3 +...

ITotal - the equivalent current in amps (A).

I1 - current of load #1 in amps (A).
I2 - current of load #2 in amps (A).
I3 - current of load #3 in amps (A).
*/
float Current_parallel(vector <float> c_parallel) { //done
    float sum = 0;
    for (const float& i : c_parallel) {
        sum = sum + i;
    }
    return sum;
}
/*
The current division of resistors in parallel is

RT = 1 / (1/R2 + 1/R3)

or

I1 = IT × RT / (R1+RT)

*/
float current_div(float R1, float R2, float R3,float It,float Rt,int type) { //done
    if (type == R_t)
    {
        float rt =1/(1/R2+1/R3); 
        return rt;
    }
    else if (type==I_1)
    {
        float I1 = It * Rt / (R1 + Rt);
        return I1;
    }
    else
    {
        return 0;
    }
   
}
/*
Alternating Current (AC)
Alternating current is generated by a sinusoidal voltage source.

Ohm's law
IZ = VZ / Z

IZ  - current flow through the load measured in amperes (A)

VZ - voltage drop on the load measured in volts (V)

Z  - impedance of the load measured in ohms (Ω)
*/
float Alterent_Current(float Vz,float Z) { //done
    float AC = Vz / Z;
    return AC;

};
/*
Angular frequency
ω = 2π f

ω - angular velocity measured in radians per second (rad/s)

f  - frequency measured in hertz (Hz).

Momentary current
*/
float  Angular_Frequancy(float frequancy) { //done
    float w = 2 * frequancy * Pi;
    return w;

}
/*
Momentary current
i(t) = Ipeak sin(ωt+θ)

i(t)      - momentary current at time t, measured in amps (A).

Ipeak - maximal current (=amplitude of sine), measured in amps (A).

ω      - angular frequency measured in radians per second (rad/s).

t        - time, measured in seconds (s).

θ       - phase of sine wave in radians (rad).
*/
float Mumentary_currant(float Ipeak,float w ,float temp, float θ) { //done

    float i_t = Ipeak * sin((w * temp) + θ);
    return i_t;
}
/*
RMS (effective) current
Irms =  Ieff =  Ipeak / √2 ≈ 0.707 Ipeak
*/
float RMS_current(float Ipeak) { //done

    float rms = Ipeak * RMS_Const;
    return rms;

}
/*
Peak-to-peak current
Ip-p = 2Ipeak
*/
float Ip_p(float Ipeak) { //done
    float i_pp = Ipeak * 2;
    return i_pp;
}
/*
The resistance of a conductor is resistivity of the conductor's material times the conductor's length divided by the conductor's cross sectional area.

R=ρ*l/a

R is the resistance in ohms (Ω).

ρ is the resistivity in ohms-meter (Ω×m)

l is the length of the conductor in meter (m)

A is the cross sectional area of the conductor in square meters (m2)
*/
float Resistance(float ρ ,float l ,float a) { //done
    float r = ρ * (l / a);
    return r; 
}
/*
Resistance calculation with ohm's law

R=V/I
R is the resistance of the resistor in ohms (Ω).

V is the voltage drop on the resistor in volts (V).

I is the current of the resistor in amperes (A).
*/
float Resistance_Ohm(float v, float i) { //done
    float r = v / i;
    return r;
}
/*
Temperature effects of resistance
The resistance of a resistor increases when temperature of the resistor increases.
R2 = R1 × ( 1 + α(T2 - T1) )
R2 is the resistance at temperature T2 in ohms (Ω).
R1 is the resistance at temperature T1 in ohms (Ω).
α is the temperature coefficient.
*/
float Temperature_eff(float r1,float α,float T1,float T2) { //done
    float r2 = r1 * (1 + α*(T2 - T1));
    return r2;
}
/*
Resistance of resistors in series
The total equivalent resistance of resistors in series is the sum of the resistance values:
RTotal = R1+ R2+ R3+..
*/
float Resistance_series(vector<float>r_series) { //done
    float sum = 0;
    for (const float & i : r_series) {
        sum = sum + i;
    }
    return sum;

}
/*
Resistance of resistors in parallel
The total equivalent resistance of resistors in parallel is given by:
1/Rtotal=1/R1+1/R2+1/R3.........
*/
float Resistance_parallel(vector<float>r_series) { //done
    float sum = 0;
    for (const float & i : r_series) {
        sum = sum + (1/i);
    }
    return sum;
}
/*
Electric power definition
The electric power P is equal to the energy consumption E divided by the consumption time t:

P=E/T

P is the electric power in watt (W).
E is the energy consumption in joule (J).
t is the time in seconds (s).
Electric power calculation
P = V ⋅ I

or

P = I² ⋅ R

or

P = V² / R

P is the electric power in watt (W).
V is the voltage in volts (V).
I is the current in amps (A).
R is the resistance in ohms (Ω).

The formulas are for single phase AC power.

For 3 phase AC power:

 When line to line voltage (VL-L) is used in the formula, multiply the single phase power by square root of 3 (√3=1.73).

When line to zero voltage (VL-0) is used in the formula, multiply the single phase power by 3.

put the the value as string with its unit : power("12vol","143sec")

types of unit ("jou", "sec", "vol", "amp", "ohm")

If you are working with a DC circuit let the angle be NULL
You can put NULL when you are not using any parameter*/
float power(string i, string r, float angle,int circuit,int type) { //done
    if (circuit == AC_circuit_single_phase)
    {
        string types[5] = { "jou", "sec", "vol", "amp", "ohm" };
        string lti = i.substr(i.length() - 3);
        string ltr = r.substr(r.length() - 3);
        string numberParti = i.substr(0, i.length() - 3);
        float numberi = stof(numberParti);
        string numberPartr = r.substr(0, r.length() - 3);
        float numberr = stof(numberPartr);
        bool iis = false;
        bool ris = false;
        for (int j = 0; j < 5; j++)
        {
            if (lti == types[j])
            {
                iis = true;
            }
        }
        for (int j = 0; j < 5; j++)
        {
            if (ltr == types[j])
            {
                ris = true;
            }
        }
        if (!iis || !ris)
        {
            return -1;
        }


        if (lti == types[0] && ltr == types[1])
        {
            return numberi / numberr;
        }
        else if (lti == types[1] && ltr == types[0])
        {
            return numberr / numberi;
        }
        else if (lti == types[2] && ltr == types[3])
        {
            return numberi * numberr * cos(angle);
        }
        else if (lti == types[3] && ltr == types[2])
        {
            return numberr * numberi * cos(angle);
        }
        else if (lti == types[3] && ltr == types[4])
        {
            return pow(numberi, 2) * numberr * cos(angle);
        }
        else if (lti == types[4] && ltr == types[3])
        {
            return pow(numberr, 2) * numberi * cos(angle);
        }
        else if (lti == types[2] && ltr == types[4])
        {
            return pow(numberi, 2) / numberr * cos(angle);
        }
        else if (lti == types[4] && ltr == types[2])
        {
            return pow(numberr, 2) / numberi * cos(angle);
        }

    }
    else if (circuit == DC_circuit)
    {
        string types[5] = { "jou", "sec", "vol", "amp", "ohm" };
        string lti = i.substr(i.length() - 3);
        string ltr = r.substr(r.length() - 3);
        string numberParti = i.substr(0, i.length() - 3);
        float numberi = stof(numberParti);
        string numberPartr = r.substr(0, r.length() - 3);
        float numberr = stof(numberPartr);
        bool iis = false;
        bool ris = false;
        for (int j = 0; j < 5; j++)
        {
            if (lti == types[j])
            {
                iis = true;
            }
        }
        for (int j = 0; j < 5; j++)
        {
            if (ltr == types[j])
            {
                ris = true;
            }
        }
        if (!iis || !ris)
        {
            return -1;
        }


        if (lti == types[0] && ltr == types[1])
        {
            return numberi / numberr;
        }
        else if (lti == types[1] && ltr == types[0])
        {
            return numberr / numberi;
        }
        else if (lti == types[2] && ltr == types[3])
        {
            return numberi * numberr;
        }
        else if (lti == types[3] && ltr == types[2])
        {
            return numberr * numberi;
        }
        else if (lti == types[3] && ltr == types[4])
        {
            return pow(numberi, 2) * numberr;
        }
        else if (lti == types[4] && ltr == types[3])
        {
            return pow(numberr, 2) * numberi;
        }
        else if (lti == types[2] && ltr == types[4])
        {
            return pow(numberi, 2) / numberr;
        }
        else if (lti == types[4] && ltr == types[2])
        {
            return pow(numberr, 2) / numberi;
        }

    }
    else if (circuit==AC_cicuit_3_phase && type ==line_to_line)
    {
        string types[5] = { "jou", "sec", "vol", "amp", "ohm" };
        string lti = i.substr(i.length() - 3);
        string ltr = r.substr(r.length() - 3);
        string numberParti = i.substr(0, i.length() - 3);
        float numberi = stof(numberParti);
        string numberPartr = r.substr(0, r.length() - 3);
        float numberr = stof(numberPartr);
        bool iis = false;
        bool ris = false;
        for (int j = 0; j < 5; j++)
        {
            if (lti == types[j])
            {
                iis = true;
            }
        }
        for (int j = 0; j < 5; j++)
        {
            if (ltr == types[j])
            {
                ris = true;
            }
        }
        if (!iis || !ris)
        {
            return -1;
        }


        if (lti == types[0] && ltr == types[1])
        {
            return numberi / numberr;
        }
        else if (lti == types[1] && ltr == types[0])
        {
            return numberr / numberi;
        }
        else if (lti == types[2] && ltr == types[3])
        {
            return sqrt(3)*numberi * numberr*cos(angle);
        }
        else if (lti == types[3] && ltr == types[2])
        {
            return sqrt(3)*numberr * numberi*cos(angle);
        }
        else if (lti == types[3] && ltr == types[4])
        {
            return 3*pow(numberi, 2) * numberr*cos(angle);
        }
        else if (lti == types[4] && ltr == types[3])
        {
            return 3*pow(numberr, 2) * numberi*cos(angle);
        }
        else if (lti == types[2] && ltr == types[4])
        {
            return 3*(pow(numberi, 2) / numberr)*cos(angle);
        }
        else if (lti == types[4] && ltr == types[2])
        {
            return 3*(pow(numberr, 2) / numberi)*cos(angle);
        }


    }
    else if (circuit==AC_cicuit_3_phase&&type==line_to_zero)
    {
        string types[5] = { "jou", "sec", "vol", "amp", "ohm" };
        string lti = i.substr(i.length() - 3);
        string ltr = r.substr(r.length() - 3);
        string numberParti = i.substr(0, i.length() - 3);
        float numberi = stof(numberParti);
        string numberPartr = r.substr(0, r.length() - 3);
        float numberr = stof(numberPartr);
        bool iis = false;
        bool ris = false;
        for (int j = 0; j < 5; j++)
        {
            if (lti == types[j])
            {
                iis = true;
            }
        }
        for (int j = 0; j < 5; j++)
        {
            if (ltr == types[j])
            {
                ris = true;
            }
        }
        if (!iis || !ris)
        {
            return -1;
        }


        if (lti == types[0] && ltr == types[1])
        {
            return numberi / numberr;
        }
        else if (lti == types[1] && ltr == types[0])
        {
            return numberr / numberi;
        }
        else if (lti == types[2] && ltr == types[3])
        {
            return sqrt(3) * numberi * numberr * cos(angle);
        }
        else if (lti == types[3] && ltr == types[2])
        {
            return sqrt(3) * numberr * numberi * cos(angle);
        }
        else if (lti == types[3] && ltr == types[4])
        {
           return 3 * pow(numberi, 2) * numberr * cos(angle);
        }
        else if (lti == types[4] && ltr == types[3])
        {
            return 3 * pow(numberr, 2) * numberi * cos(angle);
        }
        else if (lti == types[2] && ltr == types[4])
        {
            return 3 * (pow(numberi, 2) / numberr) * cos(angle);
        }
        else if (lti == types[4] && ltr == types[2])
        {
            return 3 * (pow(numberr, 2) / numberi) * cos(angle);
        }
    }
    
    else
    {
     return -1;
        
    }

}
/*

/*
Real power
Real or true power is the power that is used to do the work on the load.

P = Vrms X Irms X cos φ

P is the real power in watts [W]

Vrms is the rms voltage = Vpeak/√2 in Volts [V]

Irms is the rms current = Ipeak/√2 in Amperes [A]

φ  is the impedance phase angle = phase difference between voltage and current.
*/
float Power_Real(float Vrms,float Irms,float φ){ //done
    float p = Vrms * Irms * cos(φ);
    return p;
}
/*
Reactive power
Reactive power is the power that is wasted and not used to do work on the load.

Q = Vrms X Irms X sin φ

Q is the reactive power in volt-ampere-reactive [VAR]
Vrms  is the rms voltage = Vpeak/√2 in Volts [V]
Irms   is the rms current = Ipeak/√2 in Amperes [A]
φ      is the impedance phase angle = phase difference between voltage and current.

*/
float Reactive_power(float Vrms,float Irms,float φ) { //done
    float p = Vrms * Irms * sin(φ);
    return p;

 }
/*
Apparent power
The apparent power is the power that is supplied to the circuit.

S = Vrms Irms



S      is the apparent power in Volt-amper [VA]

Vrms  is the rms voltage = Vpeak/√2 in Volts [V]

Irms   is the rms current = Ipeak/√2 in Amperes [A]

*/
float Apperent_power(float vrms,float Irms) { //done
    float p = vrms * Irms;
    return p;


}
/*
Real / reactive / apparent powers relation
The real power P and reactive power Q give together the apparent power S:
P² + Q² = S²
P      is the real power in watts [W]
Q      is the reactive power in volt-ampere-reactive [VAR]
S      is the apparent power in Volt-amper [VA]
note :
   W=wat
   va=vam
*/

float relation_real_reactive_apperant(string i ,string r ) { //done
    string types[5] = { "wat", "var", "vam"};
    string lti = i.substr(i.length() - 3);
    string ltr = r.substr(r.length() - 3);
    string numberParti = i.substr(0, i.length() - 3);
    float numberi = stof(numberParti);
    string numberPartr = r.substr(0, r.length() - 3);
    float numberr = stof(numberPartr);
    bool iis = false;
    bool ris = false;
    for (int j = 0; j < 5; j++)
    {
        if (lti == types[j])
        {
            iis = true;
        }
    }
    for (int j = 0; j < 5; j++)
    {
        if (ltr == types[j])
        {
            ris = true;
        }
    }
    if (!iis || !ris)
    {
        return -1;
    }


    if (lti == types[0] && ltr == types[1])
    {
        return sqrt(numberi + numberr);
    }
    else if (lti == types[1] && ltr == types[0])
    {
        return sqrt(numberr + numberi);
    }
    else if (lti == types[1] && ltr == types[2])
    {
        return sqrt(numberi - numberr);
    }
    else if (lti == types[2] && ltr == types[1])
    {
        return sqrt(numberr - numberi);
    }
    else if (lti == types[0] && ltr == types[2])
    {
        return  sqrt(numberi- numberr);
    }
    else if (lti == types[2] && ltr == types[0])
    {
        return sqrt(numberr - numberi);
    }
   
}
/*
Electric charge calculation
When electric current flows for a specified time, we can calculate the charge:

Constant current
Q = I ⋅ t

Q is the electric charge, measured in coulombs [C].

I is the current, measured in amperes [A].

t is the time period, measured in seconds [s].
*/
float electric_charge(string i, string r) { //done
    string types[3] = { "sec", "amp", "cou" };

    string lti = i.substr(i.length() - 3);
    string ltr = r.substr(r.length() - 3);

    string numberParti = i.substr(0, i.length() - 3);
    float numberi = stof(numberParti);

    string numberPartr = r.substr(0, r.length() - 3);
    float numberr = stof(numberPartr);

    bool iis = false;
    bool ris = false;

    for (int j = 0; j < 3; j++)
    {
        if (lti == types[j])
        {
            iis = true;
        }
    }
    for (int j = 0; j < 3; j++)
    {
        if (ltr == types[j])
        {
            ris = true;
        }
    }
    if (!iis || !ris)
    {
        return -1;
    }


    if (lti == types[0] && ltr == types[1])
    {
        return numberi / numberr;
    }
    else if (lti == types[0] && ltr == types[2])
    {
        return numberi / numberr;
    }
    else if (lti == types[2] && ltr == types[0])
    {
        return numberr / numberi;
    }
    else if (lti == types[1] && ltr == types[2])
    {
        return numberi * numberr;
    }
    else if (lti == types[2] && ltr == types[1])
    {
        return numberi * numberr;
    }
    else if (lti == types[1] && ltr == types[0])
    {
        return numberr / numberi;
    }
    else {
        return -1;
    }
}
/*
Coulomb's law formula
Coulomb's law calculates the electric force F in newtons (N) between two electric charges q1 and q2 in coulombs (C)

with a distance of r in meters (m):



F=k.q1.q2/R²

F is the force on q1 and q2 measured in newtons (N).

k is Coulomb's constant k = 8.988×109 N⋅m2/C2

q1 is the first charge in coulombs (C).

q2 is the second charge in coulombs (C).

r is the distance between the 2 charges in meters (m).
*/
float Coulombs_Law(float q1, float q2, float r) { //done
    float f;
    f = (q1 * q2 * coulomb_constant) / pow(r, 2);
    return f;
}

/*
Electric Power Efficiency
Power efficiency
Power efficiency is defined as the ratio of the output power divided by the input power:

η = 100% ⋅ Pout / Pin

η is the efficiency in percent (%).

Pin is the input power consumption in watts (W).

Pout is the output power or actual work in watts (W).

Example
Electric motor has input power consumption of 50 watts.

The motor was activated for 60 seconds and produced work of 2970 joules.

Find the efficiency of the motor.

Energy efficiency
Energy efficiency is defined as the ratio of the output energy divided by the input energy:

η = 100% ⋅ Eout / Ein

η is the efficiency in percent (%).

Ein is the input energy consumed in joule (J).

Eout is the output energy or actual work in joule (J).
*/
float efficiency(float in, float out) {
    float e = 100 * (out / in);
    return e;
}
/*
Power factor definition
The power factor is equal to the real or true power P in watts (W) divided by the apparent power |S| in volt-ampere (VA):

PF = P(W) / |S(VA)|
PF - power factor.
P   - real power in watts (W).
|S|   - apparent power - the magnitude of the complex power in volt⋅amps (VA).
*/

float Power_factor(float power_real, float apparent_power) {
    float pf = power_real / apparent_power;
    return pf;
}


namespace units_conv {

    // Voltage conversions
    double VoltsToMillivolts(double volts) { return volts * 1000.0; }
    double VoltsToKilovolts(double volts) { return volts / 1000.0; }
    double VoltsToMicrovolts(double volts) { return volts * 1e6; }
    double MillivoltsToVolts(double millivolts) { return millivolts / 1000.0; }
    double KilovoltsToVolts(double kilovolts) { return kilovolts * 1000.0; }
    double MicrovoltsToVolts(double microvolts) { return microvolts / 1e6; }

    // Current conversions
    double AmperesToMilliamperes(double amperes) { return amperes * 1000.0; }
    double AmperesToKiloamperes(double amperes) { return amperes / 1000.0; }
    double AmperesToMicroamperes(double amperes) { return amperes * 1e6; }
    double MilliamperesToAmperes(double milliamperes) { return milliamperes / 1000.0; }
    double KiloamperesToAmperes(double kiloamperes) { return kiloamperes * 1000.0; }
    double MicroamperesToAmperes(double microamperes) { return microamperes / 1e6; }

    // Resistance conversions
    double OhmsToKiloohms(double ohms) { return ohms / 1000.0; }
    double OhmsToMegaohms(double ohms) { return ohms / 1e6; }
    double OhmsToMilliohms(double ohms) { return ohms * 1000.0; }
    double KiloohmsToOhms(double kiloohms) { return kiloohms * 1000.0; }
    double MegaohmsToOhms(double megaohms) { return megaohms * 1e6; }
    double MilliohmsToOhms(double milliohms) { return milliohms / 1000.0; }

    // Power conversions
    double WattsToMilliwatts(double watts) { return watts * 1000.0; }
    double WattsToKilowatts(double watts) { return watts / 1000.0; }
    double WattsToMicrowatts(double watts) { return watts * 1e6; }
    double MilliwattsToWatts(double milliwatts) { return milliwatts / 1000.0; }
    double KilowattsToWatts(double kilowatts) { return kilowatts * 1000.0; }
    double MicrowattsToWatts(double microwatts) { return microwatts / 1e6; }

    // Capacitance conversions
    double FaradsToMicrofarads(double farads) { return farads * 1e6; }
    double FaradsToNanofarads(double farads) { return farads * 1e9; }
    double FaradsToPicofarads(double farads) { return farads * 1e12; }
    double MicrofaradsToFarads(double microfarads) { return microfarads / 1e6; }
    double NanofaradsToFarads(double nanofarads) { return nanofarads / 1e9; }
    double PicofaradsToFarads(double picofarads) { return picofarads / 1e12; }

    // Inductance conversions
    double HenriesToMillihenries(double henries) { return henries * 1000.0; }
    double HenriesToMicrohenries(double henries) { return henries * 1e6; }
    double MillihenriesToHenries(double millihenries) { return millihenries / 1000.0; }
    double MicrohenriesToHenries(double microhenries) { return microhenries / 1e6; }

    // Conductance conversions
    double SiemensToMillisiemens(double siemens) { return siemens * 1000.0; }
    double MillisiemensToSiemens(double millisiemens) { return millisiemens / 1000.0; }
    // Energy conversions
    double KilowattHoursToWattHours(double kWh) {return kWh * 1000.0;}
    double WattHoursToKilowattHours(double Wh) { return Wh / 1000.0; }
    double KilowattHoursToJoules(double kWh) {return kWh * 3.6e6;}
    double JoulesToKilowattHours(double joules) {return joules / 3.6e6;}
    double WattHoursToJoules(double Wh) { return Wh * 3600.0; }
    double JoulesToWattHours(double joules) {return joules / 3600.0;}
    double JoulesToCalories(double joules) {return joules / 4.184;}
    double CaloriesToJoules(double calories) {return calories * 4.184;}
    double JoulesToKilocalories(double joules) {return joules / 4184.0;}
    double KilocaloriesToJoules(double kilocalories) {return kilocalories * 4184.0;}
    double JoulesToElectronvolts(double joules) {return joules / 1.60218e-19;}
    double ElectronvoltsToJoules(double electronvolts) {return electronvolts * 1.60218e-19;}
}
namespace elctronics_components {
    namespace Capacitor {
        // Function to calculate capacitance (C = Q / V)
        double CalculateCapacitance(double charge, double voltage) {
            return charge / voltage;
        }

        // Function to calculate charge (Q = C * V)
        double CalculateCharge(double capacitance, double voltage) {
            return capacitance * voltage;
        }

        // Function to calculate voltage (V = Q / C)
        double CalculateVoltage(double charge, double capacitance) {
            return charge / capacitance;
        }

        // Function to calculate energy stored in the capacitor (E = 0.5 * C * V^2)
        double CalculateEnergy(double capacitance, double voltage) {
            return 0.5 * capacitance * pow(voltage, 2);
        }

        // Function to calculate equivalent capacitance in series (1/C_eq = 1/C1 + 1/C2 + ...)
        double CalculateSeriesCapacitance(const std::vector<double>& capacitances) {
            double reciprocalSum = 0.0;
            for (double capacitance : capacitances) {
                reciprocalSum += 1.0 / capacitance;
            }
            return 1.0 / reciprocalSum;
        }

        // Function to calculate equivalent capacitance in parallel (C_eq = C1 + C2 + ...)
        double CalculateParallelCapacitance(const std::vector<double>& capacitances) {
            double sum = 0.0;
            for (double capacitance : capacitances) {
                sum += capacitance;
            }
            return sum;
        }
   }
    namespace indactor {
        // Function to calculate inductance (L = V * t / I)
        double CalculateInductance(double voltage, double time, double current) {
            return (voltage * time) / current;
        }

        // Function to calculate voltage across the inductor (V = L * dI/dt)
        double CalculateInductorVoltage(double inductance, double currentChangeRate) {
            return inductance * currentChangeRate;
        }

        // Function to calculate current through the inductor (I = V * t / L)
        double CalculateInductorCurrent(double voltage, double time, double inductance) {
            return (voltage * time) / inductance;
        }

        // Function to calculate energy stored in the inductor (E = 0.5 * L * I^2)
        double CalculateInductorEnergy(double inductance, double current) {
            return 0.5 * inductance * pow(current, 2);
        }

        // Function to calculate equivalent inductance in series (L_eq = L1 + L2 + ...)
        double CalculateSeriesInductance(const std::vector<double>& inductances) {
            double sum = 0.0;
            for (double inductance : inductances) {
                sum += inductance;
            }
            return sum;
        }

        // Function to calculate equivalent inductance in parallel (1/L_eq = 1/L1 + 1/L2 + ...)
        double CalculateParallelInductance(const std::vector<double>& inductances) {
            double reciprocalSum = 0.0;
            for (double inductance : inductances) {
                reciprocalSum += 1.0 / inductance;
            }
            return 1.0 / reciprocalSum;
        }

    }
    namespace Risistor {
        // Function to calculate resistance of a 4-band resistor
        double Calculate4BandResistor(int digit1, int digit2, double multiplier) {
            return (10 * digit1 + digit2) * multiplier;
        }

        // Function to calculate resistance of a 5-band or 6-band resistor
        double Calculate5Or6BandResistor(int digit1, int digit2, int digit3, double multiplier) {
            return (100 * digit1 + 10 * digit2 + digit3) * multiplier;
        }

    }
}



